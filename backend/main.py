from fastapi import FastAPI, HTTPException, Depends
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
import mysql.connector
from typing import List, Optional, Dict, Any
import json
import os
import sys

# Ensure src is in path for hybrid_model import
sys.path.append(os.path.join(os.path.dirname(__file__), '..'))
import joblib
from brain import generate_decision_explanation

class ChatRequest(BaseModel):
    user_id: int
    query: str

app = FastAPI(title="BoursaGPT")

# Database Configuration
db_config = {
    "host": "localhost",
    "user": "root",
    "password": "oba2005lala!",
    "database": "boursagpt"
}
class MarketSentiment(BaseModel):
    ticker: str
    global_sentiment_score: float
    market_consensus: Optional[str] = "HOLD"
    summary: Optional[str] = "Analyse confidentielle en cours..."
    last_updated: Optional[str] = "Maintenant"
    news_analysis: Optional[List[Dict[str, Any]]] = None

# --- HELPER: Read the Shared Cache (Layer 3) ---
CACHE_FILE = os.path.join(os.path.dirname(__file__), "module2", "market_news_cache.json")


def get_market_data_from_cache():
    """Reads the JSON file generated by the Watchdog script."""
    if not os.path.exists(CACHE_FILE):
        # Return empty dict if the watchdog hasn't run yet
        return {}
    
    try:
        with open(CACHE_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception as e:
        print(f"Error reading cache: {e}")
        return {}

def get_db_connection():
    try:
        conn = mysql.connector.connect(**db_config)
        return conn
    except mysql.connector.Error as err:
        raise HTTPException(status_code=500, detail=f"Erreur de connexion DB: {err}") 
# CORS Middleware for React Frontend
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Pydantic Models for Request Bodies
# ... (Previous imports remain, ensure Optional is imported)

# Pydantic Models
class SignupRequest(BaseModel):
    email: str
    password: str
    full_name: str

class UpdateRoleRequest(BaseModel):
    role: str

class UpdateRiskProfileRequest(BaseModel):
    risk_profile: str

class UserResponse(BaseModel):
    id: int
    full_name: str
    email: str
    role: Optional[str] = None
    risk_profile: Optional[str] = None
    capital: float
class LoginRequest(BaseModel):
    email: str
    password: str

class PortfolioItem(BaseModel):
    ticker: str
    company_name: str
    quantity: float
    buy_price: float
    current_price: float

class Alert(BaseModel):
    id: int
    symbol: str
    message: str
    severity: str
    timestamp: str

class AddFundsRequest(BaseModel):
    amount: float

class PasswordUpdate(BaseModel):
    currentPassword: str
    newPassword: str
    confirmPassword: str

class TradeRequest(BaseModel):
    user_id: int
    ticker: str
    quantity: float
    purchase_price: float

class DemoPortfolioItem(BaseModel):
    id: int
    ticker: str
    quantity: float
    purchase_price: float

@app.post("/users/{user_id}/add-funds")
def add_funds(user_id: int, request: AddFundsRequest):
    conn = get_db_connection()
    cursor = conn.cursor()
    try:
        query = "UPDATE users SET capital = capital + %s WHERE id = %s"
        cursor.execute(query, (request.amount, user_id))
        conn.commit()
        return {"message": f"{request.amount} TND ajout√©s avec succ√®s", "success": True}
    finally:
        cursor.close()
        conn.close()
# ... (Previous PortfolioItem and Alert models remain)

# --- API Endpoints ---

# 1. Signup (POST /auth/signup)
@app.post("/auth/signup", response_model=UserResponse)
def signup(request: SignupRequest):
    conn = get_db_connection()
    cursor = conn.cursor(dictionary=True)
    try:
        # Check if user exists
        check_query = "SELECT * FROM users WHERE email = %s"
        cursor.execute(check_query, (request.email,))
        if cursor.fetchone():
            raise HTTPException(status_code=400, detail="Email already registered")

        # Insert new user with capital = 0
        insert_query = """
            INSERT INTO users (email, password, full_name, capital, role, risk_profile) 
            VALUES (%s, %s, %s, 0, NULL, NULL)
        """
        cursor.execute(insert_query, (request.email, request.password, request.full_name))
        conn.commit()
        user_id = cursor.lastrowid
        
        return {
            "id": user_id,
            "full_name": request.full_name,
            "email": request.email,
            "role": None,
            "risk_profile": None,
            "capital": 0.0
        }
    except mysql.connector.Error as err:
        raise HTTPException(status_code=500, detail=str(err))
    finally:
        cursor.close()
        conn.close()

# 2. Update Role (PATCH /users/{user_id}/role)
@app.patch("/users/{user_id}/role")
def update_role(user_id: int, request: UpdateRoleRequest):
    conn = get_db_connection()
    cursor = conn.cursor()
    try:
        query = "UPDATE users SET role = %s WHERE id = %s"
        cursor.execute(query, (request.role, user_id))
        conn.commit()
        
        if cursor.rowcount == 0:
            raise HTTPException(status_code=404, detail="User not found")
            
        return {"message": "Role updated successfully", "success": True}
    except mysql.connector.Error as err:
        raise HTTPException(status_code=500, detail=str(err))
    finally:
        cursor.close()
        conn.close()

# 3. Update Risk Profile (PATCH /users/{user_id}/risk-profile)
@app.patch("/users/{user_id}/risk-profile")
def update_risk_profile(user_id: int, request: UpdateRiskProfileRequest):
    conn = get_db_connection()
    cursor = conn.cursor()
    try:
        query = "UPDATE users SET risk_profile = %s WHERE id = %s"
        cursor.execute(query, (request.risk_profile, user_id))
        conn.commit()
        
        if cursor.rowcount == 0:
            raise HTTPException(status_code=404, detail="User not found")
            
        return {"message": "Risk profile updated successfully", "success": True}
    except mysql.connector.Error as err:
        raise HTTPException(status_code=500, detail=str(err))
    finally:
        cursor.close()
        conn.close()

# 1. Login (POST /login) - Updated to include id in response if not present
@app.post("/login", response_model=UserResponse)
def login(request: LoginRequest):
    conn = get_db_connection()
    cursor = conn.cursor(dictionary=True)
    try:
        query = "SELECT id, full_name, email, role, risk_profile, capital FROM users WHERE email = %s AND password = %s"
        cursor.execute(query, (request.email, request.password))
        user = cursor.fetchone()
        
        if user:
            return user
        else:
            raise HTTPException(status_code=401, detail="Invalid email or password")
    finally:
        cursor.close()
        conn.close()

# ... (Keep get_portfolio and get_alerts as is, just ensure they are below)

# 3. Smart Portfolio (GET /portfolio/{user_id}) - UPGRADED
@app.get("/portfolio/{user_id}") # Removed response_model to allow dynamic merging
def get_portfolio(user_id: int):
    conn = get_db_connection()
    cursor = conn.cursor(dictionary=True)
    try:
        # 1. Get the hard data from MySQL (Layer 1 & 3)
        query = """
            SELECT 
                s.ticker, 
                s.company_name, 
                up.quantity, 
                up.buy_price, 
                s.current_price
            FROM user_portfolio up
            JOIN stocks s ON up.stock_id = s.id
            WHERE up.user_id = %s
        """
        cursor.execute(query, (user_id,))
        portfolio_items = cursor.fetchall()

        # 2. Get the AI Intelligence from JSON (Layer 2 & 3)
        ai_data = get_market_data_from_cache()

        # 3. MERGE THEM (Layer 4 - Decision Engine Logic)
        enriched_portfolio = []
        for item in portfolio_items:
            ticker = item['ticker']
            
            # Default values if AI hasn't analyzed this stock yet
            sentiment_info = {
                "ai_sentiment": 0,
                "ai_consensus": "NEUTRAL",
                "ai_summary": "No recent news analyzed."
            }

            # If your Watchdog found this stock, inject the intelligence
            if ticker in ai_data:
                cached_stock = ai_data[ticker]
                sentiment_info = {
                    "ai_sentiment": cached_stock.get('global_sentiment_score', 0),
                    "ai_consensus": cached_stock.get('market_consensus', 'NEUTRAL'),
                    "ai_summary": cached_stock.get('summary', '')
                }

            # Combine SQL data + AI data
            enriched_item = {**item, **sentiment_info}
            enriched_portfolio.append(enriched_item)

        return enriched_portfolio
    finally:
        cursor.close()
        conn.close()
# 4. Market Sentiment (GET /market/sentiment) - VERSION "TRENDING ONLY" üî•
# 4. Market Sentiment (GET /market/sentiment) - VERSION "TRENDING ONLY" üî•
@app.get("/market/sentiment", response_model=List[MarketSentiment])
def get_market_sentiment(
    limit: int = 10,       # On ne veut que le Top 10
    min_impact: float = 0.2 # On ignore les variations trop faibles (bruit)
):
    """
    Renvoie uniquement les actions 'Trending' (Fortement Positives ou N√©gatives).
    Trie par 'Impact Absolu' pour montrer ce qui bouge le plus.
    """
    data = get_market_data_from_cache()
    all_items = list(data.values())
    
    # √âtape 1 : Filtrer le "Bruit" (Score proche de 0)
    # On garde seulement si le score est > 0.2 OU < -0.2
    interesting_items = [
        item for item in all_items 
        if abs(item.get('global_sentiment_score', 0)) >= min_impact
    ]
    
    # √âtape 2 : Trier par "Intensit√©" (Magnitude du score)
    # On veut voir -0.9 et +0.8 EN PREMIER. +0.1 doit √™tre √† la fin.
    # La fonction 'abs()' permet de comparer l'intensit√© sans se soucier du signe.
    interesting_items.sort(
        key=lambda x: abs(x.get('global_sentiment_score', 0)), 
        reverse=True
    )
    
    # √âtape 3 : Renvoyer seulement le Top X (par d√©faut 10)
    return interesting_items[:limit]
@app.get("/alerts", response_model=List[Alert])
def get_alerts():
    conn = get_db_connection()
    cursor = conn.cursor(dictionary=True)
    try:
        # Assuming table name: fraud_alerts (id, symbol, message, severity, created_at)
        query = "SELECT id, symbol, message, severity, created_at as timestamp FROM fraud_alerts ORDER BY created_at DESC LIMIT 20"
        cursor.execute(query)
        alerts = cursor.fetchall()
        # Ensure timestamp is formatted as string if needed, depending on how MySQL returns it vs Pydantic
        for alert in alerts:
            if hasattr(alert['timestamp'], 'strftime'):
                 alert['timestamp'] = alert['timestamp'].strftime("%Y-%m-%d %H:%M:%S")
            else:
                 alert['timestamp'] = str(alert['timestamp'])
        return alerts
    finally:
        cursor.close()
        conn.close()
        
@app.get("/api/user/balance/{user_id}")
def get_virtual_balance(user_id: int):
    conn = get_db_connection()
    cursor = conn.cursor(dictionary=True)
    try:
        # Using the virtual_balance column you added
        cursor.execute("SELECT virtual_balance FROM users WHERE id = %s", (user_id,))
        result = cursor.fetchone()
        if not result:
            raise HTTPException(status_code=404, detail="User not found")
        return {"virtual_balance": float(result['virtual_balance'])}
    finally:
        cursor.close()
        conn.close()

@app.post("/api/trade/buy")
def buy_stock(request: TradeRequest):
    conn = get_db_connection()
    cursor = conn.cursor(dictionary=True)
    try:
        # 1. Check Balance
        cursor.execute("SELECT virtual_balance FROM users WHERE id = %s", (request.user_id,))
        user = cursor.fetchone()
        total_cost = request.quantity * request.purchase_price
        
        if float(user['virtual_balance']) < total_cost:
            raise HTTPException(status_code=400, detail="Insufficient virtual funds")

        # 2. Insert into demo_portfolio
        insert_query = """
            INSERT INTO demo_portfolio (user_id, ticker, quantity, purchase_price)
            VALUES (%s, %s, %s, %s)
        """
        cursor.execute(insert_query, (request.user_id, request.ticker, request.quantity, request.purchase_price))
        
        # 3. Update User Balance
        cursor.execute("UPDATE users SET virtual_balance = virtual_balance - %s WHERE id = %s", 
                       (total_cost, request.user_id))
        
        conn.commit()
        return {"status": "success", "new_balance": float(user['virtual_balance']) - total_cost}
    except Exception as e:
        conn.rollback()
        raise HTTPException(status_code=500, detail=str(e))
    finally:
        cursor.close()
        conn.close()

@app.get("/api/user/portfolio/{user_id}", response_model=List[DemoPortfolioItem])
def get_demo_portfolio(user_id: int):
    conn = get_db_connection()
    cursor = conn.cursor(dictionary=True)
    try:
        query = "SELECT id, ticker, quantity, purchase_price FROM demo_portfolio WHERE user_id = %s"
        cursor.execute(query, (user_id,))
        return cursor.fetchall()
    finally:
        cursor.close()
        conn.close()


@app.post("/api/chat")
def chat_with_ai(request: ChatRequest):
    """
    IA Chatbot that uses context from market sentiment.
    """
    try:
        # 1. Get market context
        market_data = get_market_data_from_cache()
        
        # 2. Generate response using brain.py
        response_text = generate_decision_explanation(market_data, request.query)
        
        return {"response": response_text}
    except Exception as e:
        print(f"Chat Error: {e}")
        raise HTTPException(status_code=500, detail=str(e))

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="127.0.0.1", port=8000)
